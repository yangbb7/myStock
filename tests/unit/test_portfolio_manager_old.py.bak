# Standard library imports
from datetime import datetime

# Third-party imports
import pytest

# Local imports
from core.managers.portfolio_manager import PortfolioManager

from core.exceptions import ConfigurationException
from tests.base_test import BaseTestCase, TestDataFactory


class TestPortfolioManagerIntegrated(BaseTestCase):
    """投资组合管理器测试用例 - 整合版本，覆盖所有测试场景"""
    
    @pytest.fixture
    def portfolio_config(self):
        """投资组合配置fixture"""
        return TestDataFactory.create_portfolio_config()
    
    @pytest.fixture
    def simple_portfolio_config(self):
        """简化投资组合配置fixture"""
        return {
            'initial_capital': 1000000,
            'commission_rate': 0.0003,
            'max_positions': 50
        }
    
    @pytest.fixture
    def sample_positions(self):
        """样本持仓fixture"""
        return TestDataFactory.create_sample_positions()
    
    @pytest.fixture
    def sample_orders(self):
        """样本订单fixture"""
        return TestDataFactory.create_sample_orders()
    
    @pytest.fixture
    def sample_trade(self):
        """样本交易fixture"""
        return {
            'symbol': '000001.SZ',
            'side': 'BUY',
            'quantity': 1000,
            'price': 15.0,
            'timestamp': datetime.now()
        }
    
    @pytest.fixture
    def price_data(self):
        """价格数据fixture"""
        return {
            '000001.SZ': 15.0,
            '000002.SZ': 20.0,
            '600000.SH': 25.0,
            '000858.SZ': 30.0,
            '600519.SH': 180.0
        }

    def _get_portfolio_manager(self, config):
        """获取可用的投资组合管理器实例"""
        return PortfolioManager(config)

    # === 初始化测试 ===
    @pytest.mark.unit
    def test_portfolio_manager_init_success(self, portfolio_config):
        """测试投资组合管理器正常初始化"""
        pm = self._get_portfolio_manager(portfolio_config)
        
        assert pm.initial_capital == portfolio_config['initial_capital']
        assert pm.current_cash == portfolio_config['initial_capital']
    
    @pytest.mark.unit
    def test_portfolio_manager_init_success_simple(self, simple_portfolio_config):
        """测试简化配置初始化"""
        try:
            pm = PortfolioManager(simple_portfolio_config)
            assert pm.initial_capital == 1000000
            assert pm.current_cash == 1000000
            assert pm.commission_rate == 0.0003
            if hasattr(pm, 'positions'):
                assert len(pm.positions) == 0
        except (ImportError, AttributeError, TypeError) as e:
            pytest.skip(f"简化版本PortfolioManager不可用: {e}")
    
    @pytest.mark.unit
    def test_portfolio_manager_init_invalid_capital(self):
        """测试无效初始资金"""
        config = {'initial_capital': -100000}
        with pytest.raises((ValueError, ConfigurationException, TypeError)):
            self._get_portfolio_manager(config)

    # === 仓位管理测试 ===
    @pytest.mark.unit
    def test_update_position_buy(self, simple_portfolio_config, sample_trade):
        """测试更新仓位 - 买入"""
        try:
            pm = PortfolioManager(simple_portfolio_config)
            
            # 检查是否有必要的方法
            if not hasattr(pm, 'update_position'):
                pytest.skip("update_position方法不可用")
            
            # 执行买入
            pm.update_position(sample_trade)
            
            # 验证仓位
            if hasattr(pm, 'get_position'):
                position = pm.get_position('000001.SZ')
                assert position is not None
                if isinstance(position, dict):
                    assert position.get('quantity') == 1000
                    assert position.get('avg_cost') == 15.0
            
            # 验证现金减少
            if hasattr(pm, 'calculate_commission'):
                trade_value = 1000 * 15.0
                commission = pm.calculate_commission(trade_value)
                expected_cash = 1000000 - (trade_value + commission)
                assert abs(pm.current_cash - expected_cash) < 10.0
            
        except (ImportError, AttributeError, TypeError) as e:
            pytest.skip(f"仓位更新功能不可用: {e}")
    
    @pytest.mark.unit
    def test_calculate_portfolio_value(self, portfolio_config, sample_positions, price_data):
        """测试投资组合价值计算"""
        pm = self._get_portfolio_manager(portfolio_config)
        
        try:
            # 设置模拟仓位
            if hasattr(pm, 'positions'):
                for symbol, position in sample_positions.items():
                    pm.positions[symbol] = position
            
            # 计算组合价值
            if hasattr(pm, 'calculate_portfolio_value'):
                total_value = pm.calculate_portfolio_value(price_data)
                assert total_value > 0
                
                # 验证计算逻辑：组合价值 = 现金 + 持仓市值
                position_value = sum(pos['market_value'] for pos in sample_positions.values())
                expected_value = pm.current_cash + position_value
                assert abs(total_value - expected_value) < 1000
            else:
                pytest.skip("calculate_portfolio_value方法不可用")
        except (ImportError, AttributeError, TypeError) as e:
            pytest.skip(f"组合价值计算功能不可用: {e}")
    
    @pytest.mark.unit
    def test_risk_management_position_size(self, portfolio_config):
        """测试仓位大小风险管理"""
        pm = self._get_portfolio_manager(portfolio_config)
        
        try:
            # 测试超过最大仓位数量限制
            if hasattr(pm, 'validate_position_size'):
                # 正常情况
                result = pm.validate_position_size('000001.SZ', 100000)
                assert result is True or isinstance(result, dict)
                
                # 超过限制情况
                oversized_amount = pm.initial_capital * 0.5  # 50%仓位
                result = pm.validate_position_size('000001.SZ', oversized_amount)
                assert result is False or isinstance(result, dict)
            else:
                pytest.skip("validate_position_size方法不可用")
        except (ImportError, AttributeError, TypeError) as e:
            pytest.skip(f"仓位大小验证功能不可用: {e}")
    
    @pytest.mark.unit
    def test_performance_metrics_calculation(self, portfolio_config, sample_positions):
        """测试绩效指标计算"""
        pm = self._get_portfolio_manager(portfolio_config)
        
        try:
            # 设置模拟仓位
            if hasattr(pm, 'positions'):
                for symbol, position in sample_positions.items():
                    pm.positions[symbol] = position
            
            # 计算绩效指标
            if hasattr(pm, 'calculate_performance_metrics'):
                metrics = pm.calculate_performance_metrics()
                self.assert_performance_metrics_valid(metrics)
            else:
                pytest.skip("calculate_performance_metrics方法不可用")
        except (ImportError, AttributeError, TypeError) as e:
            pytest.skip(f"绩效指标计算功能不可用: {e}")
    
    @pytest.mark.unit
    def test_commission_calculation(self, simple_portfolio_config):
        """测试佣金计算"""
        try:
            pm = PortfolioManager(simple_portfolio_config)
            
            if hasattr(pm, 'calculate_commission'):
                # 测试不同交易金额的佣金计算
                # 小额交易应该使用最小佣金
                small_amount = 10000
                commission = pm.calculate_commission(small_amount)
                expected_min = pm.min_commission  # 默认5.0
                assert commission == expected_min
                
                # 大额交易应该使用比例佣金
                large_amounts = [50000, 100000, 500000]
                for amount in large_amounts:
                    commission = pm.calculate_commission(amount)
                    expected = max(amount * pm.commission_rate, pm.min_commission)
                    assert abs(commission - expected) < 0.01
            else:
                pytest.skip("calculate_commission方法不可用")
        except (ImportError, AttributeError, TypeError) as e:
            pytest.skip(f"佣金计算功能不可用: {e}")
    
    @pytest.mark.unit
    def test_position_rebalancing(self, portfolio_config, sample_positions, price_data):
        """测试投资组合再平衡"""
        pm = self._get_portfolio_manager(portfolio_config)
        
        try:
            # 设置当前仓位
            if hasattr(pm, 'positions'):
                for symbol, position in sample_positions.items():
                    pm.positions[symbol] = position
            
            # 测试再平衡
            if hasattr(pm, 'rebalance_portfolio'):
                target_weights = {
                    '000001.SZ': 0.4,
                    '000002.SZ': 0.3,
                    '600000.SH': 0.3
                }
                
                rebalance_orders = pm.rebalance_portfolio(target_weights, price_data)
                assert isinstance(rebalance_orders, list)
                
                # 验证订单的有效性
                for order in rebalance_orders:
                    self.assert_order_valid(order)
            else:
                pytest.skip("rebalance_portfolio方法不可用")
        except (ImportError, AttributeError, TypeError) as e:
            pytest.skip(f"投资组合再平衡功能不可用: {e}")
    
    @pytest.mark.unit
    def test_cash_management(self, simple_portfolio_config):
        """测试现金管理"""
        try:
            pm = PortfolioManager(simple_portfolio_config)
            
            # 测试现金充足性检查
            if hasattr(pm, 'check_cash_availability'):
                # 足够现金
                assert pm.check_cash_availability(500000) is True
                
                # 现金不足
                assert pm.check_cash_availability(1500000) is False
            
            # 测试现金使用
            if hasattr(pm, 'allocate_cash'):
                initial_cash = pm.current_cash
                pm.allocate_cash(100000)
                assert pm.current_cash == initial_cash - 100000
            
        except (ImportError, AttributeError, TypeError) as e:
            pytest.skip(f"现金管理功能不可用: {e}")
    
    @pytest.mark.unit
    def test_portfolio_diversification_metrics(self, portfolio_config, sample_positions):
        """测试投资组合分散化指标"""
        pm = self._get_portfolio_manager(portfolio_config)
        
        try:
            # 设置仓位
            if hasattr(pm, 'positions'):
                for symbol, position in sample_positions.items():
                    pm.positions[symbol] = position
            
            # 计算分散化指标
            if hasattr(pm, 'calculate_diversification_metrics'):
                metrics = pm.calculate_diversification_metrics()
                assert isinstance(metrics, dict)
                
                # 验证指标合理性
                if 'sector_concentration' in metrics:
                    assert 0 <= metrics['sector_concentration'] <= 1
                
                if 'position_count' in metrics:
                    assert metrics['position_count'] >= 0
            else:
                pytest.skip("calculate_diversification_metrics方法不可用")
        except (ImportError, AttributeError, TypeError) as e:
            pytest.skip(f"分散化指标计算功能不可用: {e}")
    
    @pytest.mark.unit
    def test_error_handling_invalid_trade(self, simple_portfolio_config):
        """测试无效交易的错误处理"""
        try:
            pm = PortfolioManager(simple_portfolio_config)

            if hasattr(pm, 'update_position'):
                # 测试无效的交易数据
                invalid_trades = [
                    {'symbol': '', 'side': 'BUY', 'quantity': 1000, 'price': 15.0},  # 空symbol
                    {'symbol': '000001.SZ', 'side': 'INVALID', 'quantity': 1000, 'price': 15.0},  # 无效side
                    {'symbol': '000001.SZ', 'side': 'BUY', 'quantity': -1000, 'price': 15.0},  # 负数量
                    {'symbol': '000001.SZ', 'side': 'BUY', 'quantity': 1000, 'price': -15.0},  # 负价格
                ]
                
                for invalid_trade in invalid_trades:
                    with pytest.raises((ValueError, TypeError, ConfigurationException)):
                        pm.update_position(invalid_trade)
            else:
                pytest.skip("update_position方法不可用")
        except (ImportError, AttributeError, TypeError) as e:
            pytest.skip(f"交易错误处理功能不可用: {e}")
